const fs = require('fs')
const getDiscogsInfo = require('./getDiscogsInfo')
const { saveOrUpdateSongToDb } = require('./saveToDB')
const cliProgress = require('cli-progress')

const readSongFile = (i) => {
  try {
    const d = new Date(2021, 5, 23)
    d.setDate(d.getDate() + i)
    const date = `${d.getDate()}-${d.getMonth()}-${d.getFullYear()}`
    const file = fs.readFileSync(`../data/songs-${date}.json`)
    const parsed = JSON.parse(file)
    return parsed
  } catch {
    return null
  }
}

const goTroughOld = async () => {
  let i = 0
  const songs = []
  while (true) {
    const songsFromFile = readSongFile(i)
    if (!songsFromFile) {
      break
    }
    songs.push(...songsFromFile)
    i++
  }
  let succesfulCount = 0
  const bar = new cliProgress.SingleBar({}, cliProgress.Presets.shades_classic)
  bar.start(songs.length, 0)
  for (let song of songs) {
    bar.increment()
    try {
      song.notePages = song.notePages.map(({ notes, ...otherNotePageFields }) => ({
        notes: notes.map(({ note, ...otherNoteFields }) => ({
          note: note >= 12 ? note - Math.floor(note / 12) * 12 : note,
          ...otherNoteFields,
        })),
        ...otherNotePageFields,
      }))
      if (!song.language) {
        song.language = 'English'
      }
      if (!song.gap) {
        song.gap = 0
      }
      const discogsRes = await getDiscogsInfo(song)
      if (!discogsRes) {
        return
      }
      const { smallImage, bigImage, genres, styles, year, videoUrls } = discogsRes
      if (!genres) {
        song.genres = song.genre ? [song.genre] : []
      } else if (genres.includes(song.genre)) {
        song.genres = genres
      } else {
        song.genres = song.genre ? [...genres, song.genre] : genres
      }
      delete song.genre
      song.smallImage = smallImage
      song.bigImage = bigImage
      song.styles = styles
      if (!song.year) {
        song.year = year
      }
      if (!song.videoUrl && videoUrls && videoUrls.length !== 0) {
        const videoIDs = videoUrls
          .map((url) => {
            const idMatch = url.match(
              /(?:youtube\.com\/(?:[^/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?/\s]{11})/i
            )
            if (idMatch && idMatch[1]) {
              return idMatch[1]
            }
            return null
          })
          .filter((item) => item)
        song.videoId = videoIDs[0]
        if (videoIDs.length > 1) {
          if (song.alternativeVideoIds) {
            song.alternativeVideoIds = [...song.alternativeVideoIds, ...videoIDs]
          } else {
            song.alternativeVideoIds = videoIDs
          }
        }
      }
      song.gapIsAutoGenerated = true
      const res = await saveOrUpdateSongToDb(song)
      if (res.errors) {
        console.error(
          res.errors.map(({ locations, message }) => ({ message, location: locations[0] }))
        )
      }
      if (res.data) {
        succesfulCount++
        success = true
      }
    } catch (e) {
      console.log(e)
    }
  }
  bar.stop()
  console.log('Saved/updated', succesfulCount, 'of', songs.length, 'songs to DB')
}

goTroughOld()
