import { Song } from '../types/types'
import { AiFillYoutube, AiFillHourglass, AiOutlineSearch } from 'react-icons/ai'
import { useQuery } from 'urql'
import InfiniteScroll from 'react-infinite-scroll-component'
import { FaHeart } from 'react-icons/fa'
import { SongsQuery } from '../graphql/queries'
import useInput from '../hooks/useInput'
import { useState } from 'react'
import CrossedIcon from './CrossedIcon'
import useCheckBox from '../hooks/useCheckBox'
import { useEffect } from 'react'
import { useWindowDimensions } from '../hooks/useWindowDimensions'
import SongListItem from './SongListItem'
import { getFavorited } from '../utils/localStorage'

const SongSelectPage = () => {
  const [searchString, setSearchString] = useState('')
  const [page, setPage] = useState(1)
  const [songs, setSongs] = useState<Set<Song>>(new Set())
  const [showFavorited, setShowFavorited] = useState(false)

  const resetSongPage = () => {
    setSongs(new Set())
    setPage(1)
  }

  const handleSetSearh = (string: string) => {
    setSearchString(string)
    resetSongPage()
  }

  const search = useInput({
    placeholder: 'Search by title, artist, genre, language...',
    Icon: AiOutlineSearch,
    handleClick: handleSetSearh,
  })

  const hasRightGap = useCheckBox({
    Icon: AiFillHourglass,
    color: 'var(--warningColor)',
    tooltip: 'Include songs that probably have a wrong start time',
    defaultValue: true,
    onClick: () => {
      resetSongPage()
      hasVideo.setValue(true)
    },
  })

  const hasVideo = useCheckBox({
    Icon: AiFillYoutube,
    color: 'var(--dangerColor)',
    tooltip: "Include songs that don't have a video",
    defaultValue: true,
    onClick: () => {
      resetSongPage()
      hasRightGap.setValue(false)
    },
  })

  const favoritedIds = showFavorited ? getFavorited() : undefined
  const [result] = useQuery({
    query: SongsQuery,
    variables: {
      searchString,
      hasVideo: hasVideo.value,
      hasRightGap: hasRightGap.value,
      page,
      favoritedIds,
    },
  })

  const { height } = useWindowDimensions()

  const { data, error } = result

  useEffect(() => {
    if (!result.fetching && !result.error && result.data) {
      const newSongs = result.data.getSongs.songs as Song[]
      //@ts-ignore
      setSongs((oldSongs) => new Set([...oldSongs, ...newSongs]))
    }
  }, [result])

  if (error) return <p>Oh no... {error.message}</p>

  const rows: React.ReactElement[][] = []

  let i = 0
  songs.forEach(({ title, artist, _id, videoId, gapIsAutoGenerated, smallImage }) => {
    const rowNumber = Math.floor(i / 2)
    const isEven = i % 2 === 0
    let colorClass = ''
    let icon = <></>
    if (!videoId) {
      icon = <CrossedIcon Icon={AiFillYoutube} tooltip="No YouTube video" />
      colorClass = 'dangerColor'
    } else if (gapIsAutoGenerated) {
      icon = <CrossedIcon Icon={AiFillHourglass} tooltip="Video probably not synced with lyrics" />
      colorClass = 'warningColor'
    }
    const item = (
      <SongListItem
        title={title}
        artist={artist}
        key={_id}
        idString={_id.toString()}
        smallImage={smallImage}
        colorClass={colorClass}
        icon={icon}
      />
    )
    if (isEven) {
      rows[rowNumber] = [item]
    } else {
      rows[rowNumber].push(item)
    }
    i++
  })

  const searchOptionsHeight = height * 0.1
  const scrollHeight = height * 0.7

  const handleShowFavorited = () => {
    setShowFavorited(!showFavorited)
    resetSongPage()
  }

  return (
    <div className="centerX">
      <div className="SongSelectPageContainer">
        <div>
          <div className="searchOptions" style={{ height: searchOptionsHeight }}>
            <button
              style={{ backgroundColor: 'transparent', display: 'flex', flexDirection: 'column' }}
              onClick={handleShowFavorited}
            >
              <FaHeart size={50} color={'red'} />
              {showFavorited ? 'Show all' : 'Show favorited'}
            </button>
            {search.field}
            {hasVideo.field}
            {hasRightGap.field}
          </div>
          <h3>{data?.getSongs?.totalDocs || '?'} songs matched search</h3>
        </div>
        {songs ? (
          songs.size === 0 ? (
            <div>No song matched search</div>
          ) : (
            <InfiniteScroll
              dataLength={rows.length}
              next={() => setPage(page + 1)}
              hasMore={data.getSongs.hasNextPage}
              loader={<h4>Loading...</h4>}
              endMessage={<h3>--------------------------------------</h3>}
              height={scrollHeight}
              className="scrollDiv"
            >
              {rows.map(([item1, item2], i) => (
                <div className="songListRow" key={i}>
                  {item1}
                  {item2}
                </div>
              ))}
            </InfiniteScroll>
          )
        ) : null}
      </div>
    </div>
  )
}

export default SongSelectPage
