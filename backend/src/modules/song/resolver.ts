import { Resolver, Arg, Query, Mutation, ID } from 'type-graphql'

import { ObjectId } from 'mongodb'
import { getModelForClass } from '@typegoose/typegoose'
import { Song } from '../../entities'
import { NewSongInput } from './input'

const SongModel = getModelForClass(Song)

interface TextSearch {
  $search: string
}
interface Exists {
  $exists: boolean
}
interface Search {
  $text?: TextSearch
  videoId?: Exists
  gapIsAutoGenerated?: boolean
}

@Resolver((of) => Song)
export default class SongResolver {
  @Query((returns) => Song)
  async getSong(@Arg('id') id: ObjectId) {
    const song = await SongModel.findById(id).lean().exec()
    return song
  }

  @Query((returns) => [Song])
  async getSongs(
    @Arg('searchString', { nullable: true }) searchString: string,
    @Arg('hasVideo', { nullable: true }) hasVideo: boolean,
    @Arg('hasRightGap', { nullable: true }) hasRightGap: boolean
  ) {
    let search: Search = {}
    if (searchString) {
      search.$text = { $search: searchString }
    }
    if (hasVideo) {
      search.videoId = { $exists: true }
    }
    if (hasRightGap) {
      search.gapIsAutoGenerated = false
    }
    const songs = await SongModel.find(search, searchString && { score: { $meta: 'textScore' } })
    .sort(searchString ? { score: { $meta: 'textScore' } } : [['views', -1]])
    return songs
  }

  @Mutation((returns) => Song)
  async createSong(@Arg('songData') songData: NewSongInput): Promise<Song> {
    const { title, artist } = songData
    const alreadyExists = await SongModel.exists({ title, artist })
    if (alreadyExists) {
      throw new Error('Same song already exists')
    }
    return SongModel.create(songData)
  }

  @Mutation((returns) => Boolean)
  async createIndexes(): Promise<boolean> {
    try {
      await SongModel.ensureIndexes()
      return true
    } catch (e) {
      console.error(e.message)
      return false
    }
  }

  @Mutation((returns) => Song)
  async updateVideoInfo(
    @Arg('id') id: ObjectId,
    @Arg('videoId') videoId: string,
    @Arg('gap') gap: number
  ): Promise<Song> {
    const newSong = await SongModel.findOneAndUpdate(
      { _id: id },
      { videoId, gap, gapIsAutoGenerated: false },
      { new: true }
    )
    if (!newSong) {
      throw new Error("Coudn't find or update song")
    }
    return newSong
  }
}
