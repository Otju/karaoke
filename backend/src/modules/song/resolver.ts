import { Resolver, Arg, Query, Mutation, Int } from 'type-graphql'

import { ObjectId } from 'mongodb'
import { getModelForClass } from '@typegoose/typegoose'
import { Song } from '../../entities'
import { NewSongInput } from './input'
import { SongPagination } from '../../entities/songPagination'

const SongModel = getModelForClass(Song)

interface TextSearch {
  $search: string
}
interface Exists {
  $exists: boolean
}
interface Search {
  $text?: TextSearch
  videoId?: Exists
  gapIsAutoGenerated?: boolean
}

@Resolver((of) => Song)
export default class SongResolver {
  @Query((returns) => Song)
  async getSong(@Arg('id') id: ObjectId) {
    const song = await SongModel.findById(id).lean().exec()
    return song
  }

  @Query((returns) => SongPagination)
  async getSongs(
    @Arg('page', (type) => Int) page: number,
    @Arg('searchString', { nullable: true }) searchString: string,
    @Arg('hasVideo', { nullable: true }) hasVideo: boolean,
    @Arg('hasRightGap', { nullable: true }) hasRightGap: boolean
  ): Promise<SongPagination> {
    let search: Search = {}
    if (searchString) {
      search.$text = { $search: searchString }
    }
    if (hasVideo) {
      search.videoId = { $exists: true }
    }
    if (hasRightGap) {
      search.gapIsAutoGenerated = false
    }

    const paginationOptions = {
      page,
      limit: 15,
      select: [
        '_id',
        'title',
        'artist',
        'language',
        'year',
        'goldenNotes',
        'createdBy',
        'views',
        'rating',
        'ratingCount',
        'gapIsAutoGenerated',
        'videoId',
      ],
      collation: {
        locale: 'en',
      },
      sort: searchString ? { score: { $meta: 'textScore' } } : [['views', -1]],
    }

    const paginate = await SongModel.paginate(search, paginationOptions)
    const { docs, totalDocs, hasNextPage } = paginate
    return { songs: docs, totalDocs, hasNextPage }
  }

  @Mutation((returns) => Song)
  async createSong(@Arg('songData') songData: NewSongInput): Promise<Song> {
    const { title, artist } = songData
    const alreadyExists = await SongModel.exists({ title, artist })
    if (alreadyExists) {
      throw new Error('Same song already exists')
    }
    return SongModel.create(songData)
  }

  @Mutation((returns) => Boolean)
  async createIndexes(): Promise<boolean> {
    try {
      await SongModel.ensureIndexes()
      return true
    } catch (e) {
      console.error(e.message)
      return false
    }
  }

  @Mutation((returns) => Song)
  async updateVideoInfo(
    @Arg('id') id: ObjectId,
    @Arg('videoId') videoId: string,
    @Arg('gap') gap: number
  ): Promise<Song> {
    const newSong = await SongModel.findOneAndUpdate(
      { _id: id },
      { videoId, gap, gapIsAutoGenerated: false },
      { new: true }
    )
    if (!newSong) {
      throw new Error("Coudn't find or update song")
    }
    return newSong
  }

  @Mutation((returns) => Song)
  async updateOrCreateSong(@Arg('songData') songData: NewSongInput): Promise<Song> {
    const { title, artist } = songData
    const { videoId, gap, gapIsAutoGenerated, ...songDataForUpdate } = songData
    const updated = await SongModel.findOneAndUpdate({ title, artist }, songDataForUpdate, {
      new: true,
    })
    if (updated) {
      return updated
    } else {
      const response = await SongModel.create(songData)
      return response
    }
  }
}
